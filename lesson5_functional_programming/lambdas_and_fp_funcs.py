"""
LAMBDA-функции

- Лямбда-функции в Python являются анонимными. Это означает, что функция не имеет имени.
- Всегда возвращает только 1 значение

"""

anonymous_function = lambda x: x ** 2  # здесь 'x' - это аргумент анонимной функции, а 'x ** 2' - выражение этой функции
anonymous_function(3)

"""
ПРИМЕЧАНИЕ: присваивание lambda-выражения переменной не является хорошей практикой.


1. Функция Map

- принимает первым аргументом фунцию
- принимает вторым аргументом итерируемый объект (например список элементов), итерируемых объектов может быть 1 и более
- применяет указанную в функцию к каждому элементу итерируемого объекта/объектов
- возвращает специальный объект "map object", который представляет собой итератор 
  (можно использовать в цикле for/while или обращаться к нему через вызов next()), 
  чтобы получить конкретную коллецкию элементов
"""

map_result = map(str.upper, ["x", "y", "z"])  # преобразует все строки из итерируемого объекта в верхний регистр
first = next(map_result)    # возвращает самый первый элемент из получанного итератора: "X"

"""
Чтобы получить из "map object" конкретную коллекцию элементов, нужно явное преобразование 
"""
map_list = list(map_result)  # ["Y", "Z"]

"""
- В качестве функции можно передать lambda-выражение.
В данном примере в lambda-выражении участвует простая операция возведения числа в квадрат, 
которая будет применена к каждому элементу итерируемого объекта"""

map_result = map(lambda x: x ** 2, [1, 2, 3, 4, 5])
list(map_result)  # [1, 4, 9, 16, 25]

"""
- Также, в lambda-выражение можно передать объявленную ранее функцию 
  (этот вариант подходит для более объемных вычислений нежели простая однострочная операция)"""

def is_odd_or_even(a: int) -> bool:
    if a % 2 == 0:
        return True
    return False


map_result = map(lambda x: is_odd_or_even(x), [1, 2, 3, 4, 5])
list(map_result)  # [False, True, False, True, False]

"""
- итерируемых объектов может быть от 1 до бесконечности: 
  в случае множества объектов, они передаются в функцию map как позиционные аргументы, через запятую,
  а переменные, ссылающиеся на их элементы указываются в lambda-выражении (соответственно)
"""
map_result = map(lambda x, y, z: x + y + z, [1, 2, 3], [1, 2, 3])  # где x - элемент 1-го списка, y - элемент второго списка
list(map_result)  # [2, 4, 6]

"""ПРИМЕЧАНИЕ:

- Если количество элементов в итерируемых объектах разное, то элементы, выходящие за пределы равного диапазона 
НЕ будут учтены

# --------------------------------------------------------------------------------------------------------------------

2. Функция Filter

- Принимает первым аргументом функцию или None. 
  Функция служит в роли критерия фильтрации и должна возвращать булевый результат (True / False)
- Принимает вторым аргументом итерируемый объект (только один)
- Применяет функцию фильтрации к каждому элементу итерируемого объекта. 
  Если элемент соответствует условию функции, то он попадет в результирующий набор элементов.
- Возвращает специальный объект "filter_object", который является итератором и содержит только
  корректно отфильтрованные элементы исходного итерируемого объекта 
"""

filter_result = filter(lambda x: x % 2 == 0, [1, 2, 3, 4, 5])
list(filter_result)  # [2, 4]

"""
Если вместо функции фильтрации был указан None - вернется исходный набор элементов.
"""
filter_result = filter(None, [1, 2, 3, 4, 5])
list(filter_result)  # [1, 2, 3, 4, 5]

"""
3. Функция Reduce

Применяет функцию из двух аргументов кумулятивно к элементам итерируемого объекта,
слева направо, чтобы уменьшить итерируемый объект до одного значения.

- импортируется из модуля functools: 'from functools import reduce'
- принимат первым аргументом функцию (функция должна быть кумулятивная)
- принимает вторым аргументом итерируемый объект 
- принимает третьим (необязательным) аргументом начальное значение.

"""
from functools import reduce

reduce(lambda x, y: x + y, [1, 2, 3, 4, 5])  # эквивалентно: ((((1+2)+3)+4)+5) = 15

# так как итерируемый объект пустой, то вернется начальное значение: 10
reduce(lambda x, y: x + y, [], 10)

# начальное значение будет подставлено перед первым элементом
# итерируемого объекта, в данном примере, число 10 будет прибавлено к результату ((((1+2)+3)+4)+5)
reduce(lambda x, y: x + y, [1, 2, 3, 4, 5], 10)

