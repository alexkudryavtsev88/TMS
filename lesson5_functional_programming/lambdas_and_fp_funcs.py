import typing
"""
LAMBDA-функции

- Лямбда-функции в Python являются анонимными. Это означает, что функция не имеет имени.
- Всегда возвращает только 1 значение

"""

anonymous_function = lambda x: x ** 2  # здесь 'x' - это аргумент анонимной функции, а 'x ** 2' - выражение этой функции
anonymous_function(3)

"""
ПРИМЕЧАНИЕ: присваивание lambda-выражения переменной не является хорошей практикой.


1. Функция Map

- принимает первым аргументом ОБЪЕКТ ФУНКЦИИ (объект функции модуля, метода типа (класса) или лямбда-функции)
- принимает вторым (и следующими) аргументом ИТЕРИРУЕМЫЙ (Iterable) объект 
  (например, list/set/tuple или iterator/generator), Итерируемых объектов может быть 1 и более
- применяет указанную в Функцию к КАЖДОМУ ЭЛЕМЕНТУ Итерируемого объекта/объектов
- возвращает специальный объект "map object", который представляет собой ИТЕРАТОР (Iterator) 
  (можно использовать в цикле for/while или обращаться к нему через вызов next(), 
  или обернуть в list/tuple/set, чтобы получить конкретную коллецкию элементов
- функция map НЕ изменяет размер исходной коллекции!
"""

def strip_exclamation_mark(some_string: str) -> str:
    return some_string.strip('!')


# 1. Принимает первым аргументом метод типа str
map_result = map(str.upper, ['x', 'y', 'z'])  # преобразует все строки из итерируемого объекта в верхний регистр
# 2. Принимает первым аргументом лямбда-функцию
map_result2 = map(lambda x: x + '!', map_result)  # преобразует все строки из итерируемого объекта, добавляя '!'
# 3. Принимает первым аргументом стандартную функцию
map_result3 = map(strip_exclamation_mark, map_result)  # преобразует все строки из итерируемого объекта, удаляя '!'

"""
Чтобы получить из "map object" конкретную коллекцию элементов, нужно явное преобразование 
"""
print(list(map_result3))  # ['X', 'Y', 'Z']


def is_odd_or_even(a: int) -> bool:
    if a % 2 == 0:
        return True
    return False


map_result = map(is_odd_or_even, [1, 2, 3, 4, 5])
print(list(map_result))  # [False, True, False, True, False]

"""
- итерируемых объектов может быть от 1 до бесконечности: 
  в случае множества объектов, они передаются в функцию map как позиционные аргументы, через запятую,
  а переменные, ссылающиеся на их элементы указываются в lambda-выражении (соответственно)
"""
map_result = map(lambda x, y, z: x + y + z, [1, 2, 3], [1, 2, 3], [1, 2, 3])  # где x - элемент 1-го списка, y - элемент второго списка и т.д.
print(list(map_result))  # [3, 6, 9]

"""ПРИМЕЧАНИЕ:

- Если количество элементов в итерируемых объектах разное, то элементы, выходящие за пределы равного диапазона 
НЕ будут учтены

# --------------------------------------------------------------------------------------------------------------------

2. Функция Filter

- Принимает первым аргументом функцию или None. 
  Функция служит в роли критерия фильтрации и должна возвращать булевый результат (True / False)
- Принимает вторым аргументом итерируемый объект (только один)
- Применяет функцию фильтрации к каждому элементу итерируемого объекта. 
  Если элемент соответствует условию функции, то он попадет в результирующий набор элементов.
- Возвращает специальный объект "filter_object", который является итератором и содержит только
  корректно отфильтрованные элементы исходного итерируемого объекта 
"""

filter_result = filter(lambda x: x % 2 == 0, [1, 2, 3, 4, 5])
list(filter_result)  # [2, 4]

"""
Если вместо функции фильтрации был указан None - вернется исходный набор элементов.
"""
filter_result = filter(None, [1, 2, 3, 4, 5])
list(filter_result)  # [1, 2, 3, 4, 5]

"""
3. Функция Reduce

Применяет функцию из двух аргументов кумулятивно к элементам итерируемого объекта,
слева направо, чтобы уменьшить итерируемый объект до одного значения.

- импортируется из модуля functools: 'from functools import reduce'
- принимат первым аргументом функцию (функция должна быть кумулятивная)
- принимает вторым аргументом итерируемый объект 
- принимает третьим (необязательным) аргументом начальное значение.

"""
from functools import reduce

reduce_result = reduce(lambda x, y: x + y, [1, 2, 3, 4, 5])  # эквивалентно: ((((1+2)+3)+4)+5) = 15
print(reduce_result)

# так как итерируемый объект пустой, то вернется начальное значение: 10
print(reduce(lambda x, y: x - y, [], 10))

# начальное значение будет подставлено перед первым элементом
# итерируемого объекта, в данном примере, число 10 будет прибавлено к результату ((((1+2)+3)+4)+5)
reduce(lambda x, y: x + y, [1, 2, 3, 4, 5], 10)

x, y = ['a', 'b', 'c', 'd'], [1, 2, 3, 4, 5]
res = dict(zip(x, y))
print(res)



