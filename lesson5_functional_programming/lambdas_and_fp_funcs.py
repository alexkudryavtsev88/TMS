import typing
"""
LAMBDA-функции

- Лямбда-функции в Python являются анонимными. Это означает, что функция не имеет имени.
- Всегда возвращает только 1 значение

"""

anonymous_function = lambda x: x ** 2  # здесь 'x' - это аргумент анонимной функции, а 'x ** 2' - выражение этой функции
anonymous_function(3)

"""
ПРИМЕЧАНИЕ: присваивание lambda-выражения переменной не является хорошей практикой.


1. Функция Map

- принимает первым аргументом функцию
- принимает вторым аргументом итерируемый объект (например список элементов), итерируемых объектов может быть 1 и более
- применяет указанную в функцию к каждому элементу итерируемого объекта/объектов
- возвращает специальный объект "map object", который представляет собой итератор 
  (можно использовать в цикле for/while или обращаться к нему через вызов next()), 
  чтобы получить конкретную коллецкию элементов
"""

def gen():
    for i in range(1, 5):
        yield i

gen_ = gen()
print(isinstance(gen_, typing.Iterable))
print(isinstance(gen_, typing.Iterator))
print(isinstance(gen_, typing.Generator))
print(isinstance(iter([1, 2, 3]), typing.Generator))

map_result = map(lambda x: x + '!', ['x', 'y', 'z'])  # преобразует все строки из итерируемого объекта в верхний регистр
print(map_result)
first = next(map_result)    # возвращает самый первый элемент из получанного итератора: "X"
print(first)
print("-----")
for i in map_result:
    print(i)

"""
Чтобы получить из "map object" конкретную коллекцию элементов, нужно явное преобразование 
"""
map_list = list(map_result)  # ["Y", "Z"]

"""
- В качестве функции можно передать lambda-выражение.
В данном примере в lambda-выражении участвует простая операция возведения числа в квадрат, 
которая будет применена к каждому элементу итерируемого объекта"""

map_result = map(lambda x: x ** 2, [1, 2, 3, 4, 5])
list(map_result)  # [1, 4, 9, 16, 25]

"""
- Также, в lambda-выражение можно передать объявленную ранее функцию 
  (этот вариант подходит для более объемных вычислений нежели простая однострочная операция)"""

def is_odd_or_even(a: int) -> bool:
    if a % 2 == 0:
        return True
    return False


map_result = map(is_odd_or_even, [1, 2, 3, 4, 5])
print(list(map_result))  # [False, True, False, True, False]

"""
- итерируемых объектов может быть от 1 до бесконечности: 
  в случае множества объектов, они передаются в функцию map как позиционные аргументы, через запятую,
  а переменные, ссылающиеся на их элементы указываются в lambda-выражении (соответственно)
"""
map_result = map(lambda x, y, z: x + y + z, [1, 2, 3], [1, 2, 3], [1, 2, 3])  # где x - элемент 1-го списка, y - элемент второго списка
print(list(map_result))  # [3, 6, 9]

"""ПРИМЕЧАНИЕ:

- Если количество элементов в итерируемых объектах разное, то элементы, выходящие за пределы равного диапазона 
НЕ будут учтены

# --------------------------------------------------------------------------------------------------------------------

2. Функция Filter

- Принимает первым аргументом функцию или None. 
  Функция служит в роли критерия фильтрации и должна возвращать булевый результат (True / False)
- Принимает вторым аргументом итерируемый объект (только один)
- Применяет функцию фильтрации к каждому элементу итерируемого объекта. 
  Если элемент соответствует условию функции, то он попадет в результирующий набор элементов.
- Возвращает специальный объект "filter_object", который является итератором и содержит только
  корректно отфильтрованные элементы исходного итерируемого объекта 
"""

filter_result = filter(lambda x: x % 2 == 0, [1, 2, 3, 4, 5])
list(filter_result)  # [2, 4]

"""
Если вместо функции фильтрации был указан None - вернется исходный набор элементов.
"""
filter_result = filter(None, [1, 2, 3, 4, 5])
list(filter_result)  # [1, 2, 3, 4, 5]

"""
3. Функция Reduce

Применяет функцию из двух аргументов кумулятивно к элементам итерируемого объекта,
слева направо, чтобы уменьшить итерируемый объект до одного значения.

- импортируется из модуля functools: 'from functools import reduce'
- принимат первым аргументом функцию (функция должна быть кумулятивная)
- принимает вторым аргументом итерируемый объект 
- принимает третьим (необязательным) аргументом начальное значение.

"""
from functools import reduce

reduce_result = reduce(lambda x, y: x + y, [1, 2, 3, 4, 5])  # эквивалентно: ((((1+2)+3)+4)+5) = 15
print(reduce_result)

# так как итерируемый объект пустой, то вернется начальное значение: 10
print(reduce(lambda x, y: x - y, [], 10))

# начальное значение будет подставлено перед первым элементом
# итерируемого объекта, в данном примере, число 10 будет прибавлено к результату ((((1+2)+3)+4)+5)
reduce(lambda x, y: x + y, [1, 2, 3, 4, 5], 10)

class MyClass:
    def __init__(self, name):
        self.name = name

    def __add__(self, other):
        return self.__class__(
            name=f"{self.name}{other.name}"
        )


my_name1 = MyClass("Alex")
my_name2 = MyClass("Ann")
new_object = my_name1 + my_name2
print(new_object.name)

new_list = [1, 2, 3] * 2
print(new_list)




